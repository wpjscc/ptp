<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>

    <div id="result"></div>
    <script src="bundle.js"></script>
    <script src="app.js"></script>
    <script>
        echo = console.log

        var inisString = `
            [common]
            pool_count = 1
            server_host = 192.168.1.9
            server_80_port = 32126
            server_443_port = 32125
            protocol = ws
            tunnel_protocol = udp
            single_tunnel = true

            [web]
            local_host = 192.168.1.9
            local_port = 8080
            domain = 192.168.1.9:9010
        `;


        console.log(parseINIString(inisString))


        // var socket = new WebSocket("ws://192.168.1.9:32126/tunnel");

        // // Event listeners for socket events
        // socket.onopen = function () {
        //     console.log("Socket connection established");
        //     socket.send("Hello, server!");
        // };

        // socket.onmessage = function (event) {
        //     var message = event.data;
        //     console.log("Received message: " + message);
        // };

        // socket.onclose = function (event) {
        //     console.log("Socket connection closed with code: " + event.code);
        // };

        function parseINIString(data) {
            var regex = {
                section: /^\s*\[\s*([^\]]*)\s*\]\s*$/,
                param: /^\s*([^=]+?)\s*=\s*(.*?)\s*$/,
                comment: /^\s*;.*$/
            };
            var value = {};
            var lines = data.split(/[\r\n]+/);
            var section = null;
            lines.forEach(function (line) {
                if (regex.comment.test(line)) {
                    return;
                } else if (regex.param.test(line)) {
                    var match = line.match(regex.param);
                    if (section) {
                        value[section][match[1]] = match[2];
                    } else {
                        value[match[1]] = match[2];
                    }
                } else if (regex.section.test(line)) {
                    var match = line.match(regex.section);
                    value[match[1]] = {};
                    section = match[1];
                } else if (line.length == 0 && section) {
                    section = null;
                };
            });
            return value;
        }

        class ClientManager {
            static $localTunnelConnections = {};
            static $localDynamicConnections = {};
            static $configs = [];

            static createLocalTunnelConnection($inis) {
                let $common = $inis['common'];
                $common['timeout'] = $common['timeout'] || 6;
                $common['single_tunnel'] = $common['single_tunnel'] || 0;
                $common['pool_count'] = $common['pool_count'] || 1;
                $common['server_tls'] = $common['server_tls'] || false;
                $common['protocol'] = $common['protocol'] || '';
                $common['tunnel_protocol'] = $common['tunnel_protocol'] || 'tcp';
                delete $common['common'];

                Object.keys($inis).forEach(function ($key) {
                    if ($key != 'common') {
                        let $config = $inis[$key];
                        ClientManager.$configs.push(Object.assign($common, $config));
                    }
                })

                let $function = function ($config) {

                    let $protocol = $config['protocol']

                    let $tunnel_protocol = $config['tunnel_protocol']

                    new Tunnel($config).getTunnel($protocol).then(function ($connection) {
                        console.log($config)
                        let $headers = [
                            'GET /client HTTP/1.1',
                            'Host: '+$config['server_host'],
                            'User-Agent: ReactPHP',
                            'Tunnel: 1',
                            'Authorization: ' + ($config['token'] || ''),
                            'Local-Host: ' + $config['local_host'] + ':' + $config['local_port'],
                            'Domain: '+$config['domain'],
                            'Single-Tunnel: ' + ($config['single_tunnel'] || 0),
                            'Local-Tunnel-Address: '+ ($connection.getLocalAddress() || 'no local address'),
                        ];
                        $connection.write($headers.join("\r\n") + "\r\n\r\n");

                        let $bufferObj = {
                            buffer: ''
                        };

                        let $fn = null
                        $connection.on('data',  $fn = function ($chunk) {
                            $bufferObj.buffer += $chunk;
                            ClientManager.handleLocalTunnelBuffer($connection, $bufferObj, $config, $fn);
                        });

                        $connection.on('close', function () {
                            console.log('connection closed')
                            setTimeout(() => {
                                $function($config)
                            }, 3000);
                        });

                    }).catch( ($error) =>  {
                        console.log($error)

                        setTimeout(() => {
                            $function($config)
                        }, 3000);
                    })

                }
                echo(ClientManager.$configs)

                for (let i = 0; i < ClientManager.$configs.length; i++) {
                    echo(i)
                    let $number = ClientManager.$configs[i]['pool_count'] || 1;
                    for (let j = 0; j < $number; j++) {
                        $function(ClientManager.$configs[i])
                    }
                }


            }

            static handleLocalTunnelBuffer($connection, $bufferObj, $config) {
                let $pos = $bufferObj.buffer.indexOf("\r\n\r\n");
                if ($pos > -1) {

                    let $httpPos = $bufferObj.buffer.indexOf("HTTP/1.1")
                    if ($httpPos == -1) {
                        $httpPos = 0
                    }

                    let $headers = $bufferObj.buffer.substr($httpPos, $pos - $httpPos+4);
                    console.log($headers)
                    let $response = null
                    try {
                        $response = Util.parseResponse($headers);
                    } catch (e) {
                        console.log(e)
                        $connection.close();
                        return;
                    }

                    $bufferObj.buffer = $bufferObj.buffer.substr($pos + 4);

                    if ($response['statusCode'] === 200) {
                        ClientManager.addLocalTunnelConnection($connection, $response, $config);
                    }
                    else if ($response['statusCode'] === 201) {

                    }
                    else if ($response['statusCode'] === 300) {

                    }
                    else {
                        console.error($response)
                        $connection.close();
                        return;
                    }

                    ClientManager.handleLocalTunnelBuffer($connection, $bufferObj, $config);


                }

            }

            static addLocalTunnelConnection($connection, $response, $config) {
                let $uri = $response['headers']['Uri'];
                echo('local tunnel success ' + $uri + "\n");
                $config['uri'] = $uri;

                if (!ClientManager.$localTunnelConnections[$uri]) {
                    ClientManager.$localTunnelConnections[$uri] = [];
                }
                ClientManager.$localTunnelConnections[$uri].push($connection);

                $connection.on('close', function () {
                    let $index = ClientManager.$localTunnelConnections[$uri].indexOf($connection);
                    if ($index > -1) {
                        ClientManager.$localTunnelConnections[$uri].splice($index, 1);
                    }
                });

                if ($config['single_tunnel'] || false) {
                    $connection.removeAllListeners('data');
                    let $singleTunnel = new SingleTunnel();
                    $singleTunnel.overConnection($connection);
                    $singleTunnel.on('connection', function ($connection) {
                        let $bufferObj = {
                            buffer: ''
                        };
                        ClientManager.handleLocalConnection($connection, $config, $bufferObj, null);
                    });
                }


            }

            static async handleLocalConnection($connection, $config, $bufferObj, $response) {

                $connection.on('data',  async ($chunk) =>  {
                    $bufferObj.buffer += $chunk;

                    echo('start handleLocalConnection' + "\n");
                    let $proxy = null

                    if ($config['local-proxy']) {
                        // todo $proxy

                    }
                    let $r = function () {
                        return new Promise((resolve, reject) => {
                            try {
                                let $request = Util.parseRequest($bufferObj.buffer);
                                $bufferObj.buffer = '';
                                resolve($request)
                            } catch (e) {
                                console.error(e)
                                console.log('current buffer: ' + $bufferObj.buffer)
                                reject(e)
                            }
                        })
                    }

                    let i = 3
                    let $request = null
                    while (i > 0) {
                        if (!$bufferObj.buffer) {
                            console.error('no buffer')
                            i--;
                            await timeout(2000)
                        }
                        try {

                            console.log('try ' + i)
                            console.log('current buffer ' + $bufferObj.buffer)
                            $request = await $r();

                            $bufferObj.buffer = ''
                            break;
                        } catch (e) {
                            console.error(e, $bufferObj.buffer)
                            i--;
                            await timeout(2000)
                        }
                    }

                    if ($request) {
                        console.log('parse requesr success', $request)
                        // let reg = http.request({
                        //     host: "192.168.1.9",
                        //     port: "8080",
                        //     path: "/"
                        // }, (res) => {
                        //     res.on('data', function (buf) {
                        //         console.log(buf)
                        //     });

                        //     res.on('end', function () {
                        //         console.log('end')
                        //     });
                        // })
                        // reg.end()
                        let req = http.request($request, (res) => {
                            res.on('data', function (buf) {
                                console.log(buf)
                            });

                            res.on('end', function () {
                                console.log('end')
                            });
                        })

                        req.end()

                    } else {
                        console.error('timeout' + "\n");
                        $connection.close();
                    }
                });











            }


        }

        function timeout(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }


        ClientManager.createLocalTunnelConnection(parseINIString(inisString));





    </script>
</body>

</html>